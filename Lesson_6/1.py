"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков. Проанализировать
результат и определить программы с наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Результаты анализа вставьте в виде
комментариев к коду. Также укажите в комментариях версию Python
и разрядность вашей ОС.
"""

from memory_profiler import profile
import random


@profile
def simple_number(n):
    lst = []
    for i in range(2, n+1):
        for j in range(2, i):
            if i % j == 0:
                # если делитель найден, число не простое.
                break
        else:
            lst.append(i)
    return lst

@profile
def simple_number_with(n):
    a = list(range(n + 1))
    a[1] = 0
    lst_new = []

    i = 2
    while i <= n:
        if a[i] != 0:
            lst_new.append(a[i])
            for j in range(i, n+1, i):
                a[j] = 0
        i += 1
    return lst_new


if __name__ == "__main__":
    m = 10000
    simple_number(m)
    simple_number_with(m)


'''

Python 3.7.2, Win 64.

При (m = 10)
Алгоритм без решета задействует  - 20.5 MiB;
Алгоритм решето Эратосфена задействует  - 20.8 MiB;

При (m = 100)
Алгоритм без решета задействует  - 20.5 MiB;
Алгоритм решето Эратосфена задействует  - 20.6 MiB;

При (m = 1000)
Алгоритм без решета задействует  - 20.7 MiB;
Алгоритм решето Эратосфена задействует  - 20.8 MiB;

При (m = 10000)
Алгоритм без решета задействует  - 20.8 MiB;
Алгоритм решето Эратосфена задействует  - 21.0 MiB (+ 0.2 MiB для массива a = []);

Из этого эксперимента можно сделать предположение, что алгоритмы с точки зрения
использования памяти работатют с похожей эфективностью. Решето Эратосфена
использует чуть больше ввиду использования дополнительного массива a[].

Однако, если учесть совокупность покахателей (время + память), то решето также
остается более эффектиным алгоритмом по сравнению с наивным.

'''



